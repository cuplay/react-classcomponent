{"version":3,"file":"circle.js","sourceRoot":"","sources":["../../../src/plots/sankey/circle.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,YAAY,CAAC;AAGxC;;;;;GAKG;AACH,SAAS,SAAS,CAAC,WAAkC,EAAE,MAAgB,EAAE,MAAc;IACrF,kBAAkB;IAClB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;QAAE,OAAO,KAAK,CAAC;IACrC,uBAAuB;IACvB,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAAE,OAAO,IAAI,CAAC;IAEzC,KAAK;IACL,OAAO,MAAM,CAAC,IAAI,CAAC,UAAC,CAAS,IAAK,OAAA,SAAS,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,EAAlD,CAAkD,CAAC,CAAC;AACxF,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,YAAY,CAAC,IAAU,EAAE,WAAmB,EAAE,WAAmB;IAC/E,IAAM,iBAAiB,GAAG,EAAE,CAAC;IAC7B,IAAM,WAAW,GAAG,EAAE,CAAC;IAEvB,gCAAgC;IAChC,IAAM,WAAW,GAAG,IAAI,GAAG,EAAoB,CAAC;IAEhD,IAAI,CAAC,IAAI,EAAE,UAAC,CAAQ;QAClB,IAAM,MAAM,GAAG,CAAC,CAAC,WAAW,CAAW,CAAC;QACxC,IAAM,MAAM,GAAG,CAAC,CAAC,WAAW,CAAW,CAAC;QAExC,WAAW;QACX,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,EAAE;YAC7C,OAAO;YACP,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC1B,SAAS;YACT,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;gBAC5B,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;aAC7B;YACD,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACtC;aAAM;YACL,eAAe;YACf,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACrB;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;QAC5B,OAAO,CAAC,IAAI,CAAC,kCAAgC,WAAW,CAAC,MAAM,sBAAmB,EAAE,WAAW,CAAC,CAAC;KAClG;IAED,OAAO,iBAAiB,CAAC;AAC3B,CAAC","sourcesContent":["import { each, size } from '@antv/util';\nimport { Data, Datum } from '../../types';\n\n/**\n * 是否有环的判断依据是，当前 source 对应的 target 是 source 的父节点\n * @param circleCache\n * @param source\n * @param target\n */\nfunction hasCircle(circleCache: Map<string, string[]>, source: string[], target: string): boolean {\n  // 父元素为空，则表示已经到头了！\n  if (size(source) === 0) return false;\n  // target 在父元素路径上，所以形成环\n  if (source.includes(target)) return true;\n\n  // 递归\n  return source.some((s: string) => hasCircle(circleCache, circleCache.get(s), target));\n}\n\n/**\n * 切断桑基图数据中的环（会丢失数据），保证顺序\n * @param data\n * @param sourceField\n * @param targetField\n */\nexport function cutoffCircle(data: Data, sourceField: string, targetField: string): Data {\n  const dataWithoutCircle = [];\n  const removedData = [];\n\n  /** 存储父子关系的链表关系，具体是 子 -> 父 数组 */\n  const circleCache = new Map<string, string[]>();\n\n  each(data, (d: Datum) => {\n    const source = d[sourceField] as string;\n    const target = d[targetField] as string;\n\n    // 当前数据，不成环\n    if (!hasCircle(circleCache, [source], target)) {\n      // 保留数据\n      dataWithoutCircle.push(d);\n      // 存储关系链表\n      if (!circleCache.has(target)) {\n        circleCache.set(target, []);\n      }\n      circleCache.get(target).push(source);\n    } else {\n      // 保存起来用于打印 log\n      removedData.push(d);\n    }\n  });\n\n  if (removedData.length !== 0) {\n    console.warn(`sankey data contains circle, ${removedData.length} records removed.`, removedData);\n  }\n\n  return dataWithoutCircle;\n}\n"]}