"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cutoffCircle = void 0;
var util_1 = require("@antv/util");
/**
 * 是否有环的判断依据是，当前 source 对应的 target 是 source 的父节点
 * @param circleCache
 * @param source
 * @param target
 */
function hasCircle(circleCache, source, target) {
    // 父元素为空，则表示已经到头了！
    if (util_1.size(source) === 0)
        return false;
    // target 在父元素路径上，所以形成环
    if (source.includes(target))
        return true;
    // 递归
    return source.some(function (s) { return hasCircle(circleCache, circleCache.get(s), target); });
}
/**
 * 切断桑基图数据中的环（会丢失数据），保证顺序
 * @param data
 * @param sourceField
 * @param targetField
 */
function cutoffCircle(data, sourceField, targetField) {
    var dataWithoutCircle = [];
    var removedData = [];
    /** 存储父子关系的链表关系，具体是 子 -> 父 数组 */
    var circleCache = new Map();
    util_1.each(data, function (d) {
        var source = d[sourceField];
        var target = d[targetField];
        // 当前数据，不成环
        if (!hasCircle(circleCache, [source], target)) {
            // 保留数据
            dataWithoutCircle.push(d);
            // 存储关系链表
            if (!circleCache.has(target)) {
                circleCache.set(target, []);
            }
            circleCache.get(target).push(source);
        }
        else {
            // 保存起来用于打印 log
            removedData.push(d);
        }
    });
    if (removedData.length !== 0) {
        console.warn("sankey data contains circle, " + removedData.length + " records removed.", removedData);
    }
    return dataWithoutCircle;
}
exports.cutoffCircle = cutoffCircle;
//# sourceMappingURL=circle.js.map