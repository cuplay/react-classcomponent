"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformData = exports.getFommatInteractions = exports.isDrillDown = void 0;
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var treemap_1 = require("../../utils/hierarchy/treemap");
var utils_1 = require("../../utils");
function isDrillDown(interactions) {
    if (!util_1.isArray(interactions))
        return false;
    return interactions.findIndex(function (i) { return i.type === 'treemap-drill-down'; }) > -1;
}
exports.isDrillDown = isDrillDown;
function getFommatInteractions(interactions, hierarchyConfig) {
    var openDrillDown = isDrillDown(interactions);
    if (openDrillDown) {
        return interactions.map(function (i) {
            if (i.type === 'treemap-drill-down') {
                return utils_1.deepAssign({}, i, {
                    cfg: {
                        hierarchyConfig: hierarchyConfig,
                    },
                });
            }
            return i;
        });
    }
    return interactions;
}
exports.getFommatInteractions = getFommatInteractions;
function transformData(options) {
    var data = options.data, colorField = options.colorField, openDrillDown = options.openDrillDown, _a = options.hierarchyConfig, hierarchyConfig = _a === void 0 ? {} : _a;
    var nodes = treemap_1.treemap(data, tslib_1.__assign(tslib_1.__assign({}, hierarchyConfig), { 
        // @ts-ignore
        type: 'hierarchy.treemap', field: 'value', as: ['x', 'y'] }));
    var result = [];
    nodes.forEach(function (node) {
        if (node.depth === 0) {
            return null;
        }
        // 开启下钻，仅加载 depth === 1 的数据
        if (openDrillDown && node.depth !== 1) {
            return null;
        }
        // 不开启下钻，加载所有叶子节点
        if (!openDrillDown && node.children) {
            return null;
        }
        var eachNode = Object.assign({}, node.data, {
            x: node.x,
            y: node.y,
            depth: node.depth,
            value: node.value,
        });
        if (!node.data[colorField] && node.parent) {
            var ancestorNode = node.ancestors().find(function (n) { return n.data[colorField]; });
            eachNode[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
        }
        else {
            eachNode[colorField] = node.data[colorField];
        }
        result.push(eachNode);
    });
    return result;
}
exports.transformData = transformData;
//# sourceMappingURL=utils.js.map