"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformDataToNodeLinkData = exports.adjustYMetaByZero = void 0;
var util_1 = require("@antv/util");
/**
 * 查看数据是否是全负数、或者全正数
 * @param data
 * @param field
 */
function adjustYMetaByZero(data, field) {
    // 过滤出数字数据
    var numberData = data.filter(function (datum) {
        var v = util_1.get(datum, [field]);
        return util_1.isNumber(v) && !isNaN(v);
    });
    var gtZero = numberData.every(function (datum) { return util_1.get(datum, [field]) >= 0; });
    var ltZero = numberData.every(function (datum) { return util_1.get(datum, [field]) <= 0; });
    // 目前是增量更新，对 { min: 0, max: undefined } 进行 update({ max: 0 }) 会得到 { min: 0, max: 0 }
    if (gtZero) {
        return { min: 0 };
    }
    if (ltZero) {
        return { max: 0 };
    }
    return {};
}
exports.adjustYMetaByZero = adjustYMetaByZero;
/**
 * 转换数据格式为带有节点与边的数据格式
 * @param data
 * @param sourceField
 * @param targetField
 * @param weightField
 */
function transformDataToNodeLinkData(data, sourceField, targetField, weightField) {
    if (!Array.isArray(data)) {
        return {
            nodes: [],
            links: [],
        };
    }
    //   const nodes = [];
    var links = [];
    // 先使用对象方式存储
    var nodesMap = {};
    var nodesIndex = -1;
    // 数组变换成 chord layout 的数据结构
    data.forEach(function (datum) {
        var source = datum[sourceField];
        var target = datum[targetField];
        var weight = datum[weightField];
        // source node
        if (!nodesMap[source]) {
            nodesMap[source] = {
                id: ++nodesIndex,
                name: source,
            };
        }
        if (!nodesMap[target]) {
            nodesMap[target] = {
                id: ++nodesIndex,
                name: target,
            };
        }
        // links
        links.push({
            source: nodesMap[source].id,
            target: nodesMap[target].id,
            // sourceName: source,
            // targetName: target,
            value: weight,
        });
    });
    return {
        nodes: Object.values(nodesMap),
        links: links,
    };
}
exports.transformDataToNodeLinkData = transformDataToNodeLinkData;
//# sourceMappingURL=data.js.map